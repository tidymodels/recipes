% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roles.R
\name{roles}
\alias{roles}
\alias{add_role}
\alias{update_role}
\alias{remove_role}
\title{Manually Alter Roles}
\usage{
add_role(recipe, ..., new_role = "predictor", new_type = NULL)

update_role(recipe, ..., new_role = "predictor", old_role = NULL)

remove_role(recipe, ..., old_role)
}
\arguments{
\item{recipe}{An existing \code{\link[=recipe]{recipe()}}.}

\item{...}{One or more selector functions to choose which variables are
being assigned a role. See \code{\link[=selections]{selections()}} for more details.}

\item{new_role}{A character string for a single role.}

\item{new_type}{A character string for specific type that the variable should
be identified as. If left as \code{NULL}, the type is automatically identified
as the \emph{first} type you see for that variable in \code{summary(recipe)}.}

\item{old_role}{A character string for the specific role to update for the
variables selected by \code{...}. \code{update_role()} accepts a \code{NULL} as long as the
variables have only a single role.}
}
\value{
An updated recipe object.
}
\description{
\code{update_role()} alters an existing role in the recipe or assigns an initial
role to variables that do not yet have a declared role.

\code{add_role()} adds an \emph{additional} role to variables that already have a role
in the recipe. It does not overwrite old roles, as a single variable can have
multiple roles.

\code{remove_role()} eliminates a single existing role in the recipe.
}
\details{
Variables can have any arbitrary role (see the examples) but there are two
special standard roles, \code{"predictor"} and \code{"outcome"}. These two roles are
typically required when fitting a model.

\code{update_role()} should be used when a variable doesn't currently have a role
in the recipe, or to replace an \code{old_role} with a \code{new_role}. \code{add_role()}
only adds additional roles to variables that already have roles and will
throw an error when the current role is missing (i.e. \code{NA}).

When using \code{add_role()}, if a variable is selected that already has the
\code{new_role}, a warning is emitted and that variable is skipped so no duplicate
roles are added.

Adding or updating roles is a useful way to group certain variables that
don't fall in the standard \code{"predictor"} bucket. You can perform a step
on all of the variables that have a custom role with the selector
\code{\link[=has_role]{has_role()}}.

\subsection{Effects of non-standard roles}{

Recipes can label and retain column(s) of your data set that should not
be treated as outcomes or predictors. A unique identifier column or some
other ancillary data could be used to troubleshoot issues during model
development but may not be either an outcome or predictor.

For example, the \link[modeldata:biomass]{modeldata::biomass} data have a
column called \code{sample} with information about the specific sample type.
We can change that role:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{  data(biomass, package = "modeldata")

  recipe(HHV ~ ., data = biomass) \%>\%
    update_role(sample, new_role = "id variable")
}\if{html}{\out{</div>}}

This means that the \code{sample} column will not be used in the analysis but
will be retained in the data set (see more in the Examples section
below).

As another example, you might have a date column that is transformed
into features using \code{\link[=step_date]{step_date()}} or
\code{\link[=step_holiday]{step_holiday()}}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{  library(tidymodels)
  tidymodels_prefer()

  data(Chicago, package = "modeldata")
  chi_rec <- recipe(ridership ~ ., data = Chicago) \%>\% 
    # Since `date` is symbolically on the right-hand side of the formula, it
    # is treated as a predictor (i.e., has a role of "predictor")
    step_holiday(date) \%>\% 
    step_date(date)
}\if{html}{\out{</div>}}

At this point, \code{date} is kept in the dataset as-is, and will be treated
as a predictor (and will probably be converted to an integer column by
the modeling function).

One option is to remove \code{date} since it is not directly used as a model
term. \code{\link[=step_rm]{step_rm()}} is a good way to accomplish this.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{  chi_rec_rm <- chi_rec \%>\% step_rm(date)
}\if{html}{\out{</div>}}

Another approach, especially helpful during model development, is to
change the role of the column to some other value via
\code{\link[=update_role]{update_role()}}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{  chi_rec_role <- chi_rec \%>\% update_role(date, new_role = "date")
}\if{html}{\out{</div>}}

In this case, the column is still available in the data and will be
carried through the analysis (e.g.Â during resampling). This can be
helpful since, if there is a poor prediction, this column may be helpful
in diagnosing the problem.

The downside to chaining the role of the column is that it is needed at
prediction-time. This can impact development tools (such as tuning
functions) and would also be required to be in the data being predicted
once the model is deployed.

If using a non-standard role for a column, it is highly recommended that
you use the recipe within a workflow and specify \code{bake_dependent_roles}
as described in
\code{\link[hardhat:default_recipe_blueprint]{hardhat::default_recipe_blueprint()}}.
This will allow tuning and prediction functions to run without error.

With the example above:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{  library(hardhat) # require hardhat version >= 1.0.0
  # Make a new blueprint:
  date_bp <- default_recipe_blueprint(bake_dependent_roles = "date")

  chi_wflow <- 
    workflow() \%>\% 
    add_model(linear_reg()) \%>\% 
    add_recipe(chi_rec_role, blueprint = date_bp) 

  chi_fit <- fit(chi_wflow, Chicago)
  # This line will fail without the added blueprint:
  predict(chi_fit, head(Chicago))
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## # A tibble: 6 x 1
##   .pred
##   <dbl>
## 1 12.4 
## 2 14.3 
## 3 13.7 
## 4 13.6 
## 5 12.8 
## 6  1.68
}\if{html}{\out{</div>}}

It is also worth noting that
\code{\link[workflows:augment.workflow]{workflows::augment.workflow()}} can be
used to attach predictions to the data (including columns with
non-standard roles):

\if{html}{\out{<div class="sourceCode r">}}\preformatted{  augment(chi_fit, head(Chicago))
}\if{html}{\out{</div>}}
}
}
\examples{
\dontshow{if (rlang::is_installed("modeldata")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
library(recipes)
data(biomass, package = "modeldata")

# Using the formula method, roles are created for any outcomes and predictors:
recipe(HHV ~ ., data = biomass) \%>\%
  summary()

# However `sample` and `dataset` aren't predictors. Since they already have
# roles, `update_role()` can be used to make changes, to any arbitrary role:
recipe(HHV ~ ., data = biomass) \%>\%
  update_role(sample, new_role = "id variable") \%>\%
  update_role(dataset, new_role = "splitting variable") \%>\%
  summary()

# `update_role()` cannot set a role to NA, use `remove_role()` for that
\dontrun{
recipe(HHV ~ ., data = biomass) \%>\%
  update_role(sample, new_role = NA_character_)
}

# ------------------------------------------------------------------------------

# Variables can have more than one role. `add_role()` can be used
# if the column already has at least one role:
recipe(HHV ~ ., data = biomass) \%>\%
  add_role(carbon, sulfur, new_role = "something") \%>\%
  summary()

# `update_role()` has an argument called `old_role` that is required to
# unambiguously update a role when the column currently has multiple roles.
recipe(HHV ~ ., data = biomass) \%>\%
  add_role(carbon, new_role = "something") \%>\%
  update_role(carbon, new_role = "something else", old_role = "something") \%>\%
  summary()

# `carbon` has two roles at the end, so the last `update_roles()` fails since
# `old_role` was not given.
\dontrun{
recipe(HHV ~ ., data = biomass) \%>\%
  add_role(carbon, sulfur, new_role = "something") \%>\%
  update_role(carbon, new_role = "something else")
}

# ------------------------------------------------------------------------------

# To remove a role, `remove_role()` can be used to remove a single role.
recipe(HHV ~ ., data = biomass) \%>\%
  add_role(carbon, new_role = "something") \%>\%
  remove_role(carbon, old_role = "something") \%>\%
  summary()

# To remove all roles, call `remove_role()` multiple times to reset to `NA`
recipe(HHV ~ ., data = biomass) \%>\%
  add_role(carbon, new_role = "something") \%>\%
  remove_role(carbon, old_role = "something") \%>\%
  remove_role(carbon, old_role = "predictor") \%>\%
  summary()

# ------------------------------------------------------------------------------

# If the formula method is not used, all columns have a missing role:
recipe(biomass) \%>\%
  summary()
\dontshow{\}) # examplesIf}
}
